-- =================================================================
-- FASE 0: CREAR TABLAS MAESTRAS DE LOCALIZACIÓN
-- =================================================================

-- 1. Tabla de Cadenas de Supermercado
CREATE TABLE IF NOT EXISTS public.stores (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    name text UNIQUE NOT NULL,
    base_color text DEFAULT '#2e7d32',
    logo_url text,
    created_at timestamp with time zone DEFAULT now()
);

-- 2. Tabla de Sucursales
CREATE TABLE IF NOT EXISTS public.branches (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    store_id uuid REFERENCES public.stores(id),
    name text NOT NULL,
    address text,
    city text,
    created_at timestamp with time zone DEFAULT now(),
    UNIQUE(store_id, name) -- Evitar duplicados de nombre en la misma cadena
);

-- Habilitar RLS en Tablas Maestras
ALTER TABLE public.stores ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.branches ENABLE ROW LEVEL SECURITY;

-- Políticas de Lectura (Públicas)
CREATE POLICY "Lectura Pública Stores" 
ON public.stores FOR SELECT 
TO anon, authenticated 
USING (true);

CREATE POLICY "Lectura Pública Branches" 
ON public.branches FOR SELECT 
TO anon, authenticated 
USING (true);

-- Políticas de Escritura (Solo Authenticated puede crear sucursales nuevas)
CREATE POLICY "Usuarios pueden crear Branches" 
ON public.branches FOR INSERT 
TO authenticated 
WITH CHECK (true);

-- =================================================================
-- FASE 1: CREAR NUEVAS TABLAS NORMALIZADAS (CON AUDITORÍA COMPLETA)
-- =================================================================

-- 1. Tabla Maestra de Productos por Cadena (Catálogo)
-- Define QUE es el producto (Nombre, Categoría) para toda la cadena
CREATE TABLE IF NOT EXISTS public.store_products (
    store_id uuid REFERENCES public.stores(id),
    barcode text NOT NULL,
    name text,
    category text DEFAULT 'otros',
    unit_type text DEFAULT 'UN',
    image_url text,
    
    -- Auditoría de Creación
    created_at timestamp with time zone DEFAULT now(),
    created_by uuid, -- Usuario que creó el registro
    
    -- Auditoría de Actualización
    updated_at timestamp with time zone DEFAULT now(),
    updated_by uuid, -- Usuario que hizo la última modificación
    
    PRIMARY KEY (store_id, barcode)
);

-- 2. Tabla Transaccional de Precios por Sucursal
-- Define CUANTO cuesta en un local específico
CREATE TABLE IF NOT EXISTS public.branch_prices (
    branch_id uuid REFERENCES public.branches(id),
    barcode text NOT NULL,
    price numeric NOT NULL,
    
    -- Auditoría de Creación
    created_at timestamp with time zone DEFAULT now(),
    created_by uuid,
    
    -- Auditoría de Actualización
    updated_at timestamp with time zone DEFAULT now(),
    updated_by uuid,
    
    PRIMARY KEY (branch_id, barcode)
);

-- 3. Tabla de Reportes de Precios (Buzón de Entrada)
-- Aquí llegan los datos crudos de los usuarios antes de ser procesados
CREATE TABLE IF NOT EXISTS public.price_reports (
    id bigint generated by default as identity primary key,
    barcode text NOT NULL,
    price numeric NOT NULL,
    name text,
    category text,
    unit_type text DEFAULT 'UN',
    
    -- Relaciones Geográficas
    store text, -- Texto legacy (opcional)
    branch text, -- Texto legacy (opcional)
    store_id uuid REFERENCES public.stores(id),
    branch_id uuid REFERENCES public.branches(id),
    
    -- Auditoría y Estado
    user_id uuid default auth.uid(), -- Quién reportó
    status text DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    status_reason text, -- Razón del rechazo o aprobación
    created_at timestamp with time zone default timezone('utc'::text, now())
);

-- Habilitar RLS en Reportes
ALTER TABLE public.price_reports ENABLE ROW LEVEL SECURITY;

-- Políticas de Reportes
CREATE POLICY "Usuarios pueden crear reportes" 
ON public.price_reports FOR INSERT 
TO authenticated 
WITH CHECK (true);

CREATE POLICY "Usuarios ven sus propios reportes" 
ON public.price_reports FOR SELECT 
TO authenticated 
USING (auth.uid() = user_id);

-- =================================================================
-- FASE 2: MIGRACIÓN DE DATOS (Rescatar lo que ya tienes)
-- =================================================================

-- 1. Migrar Catálogo Único (Nombres) desde la tabla vieja 'products'
INSERT INTO public.store_products (
    store_id, barcode, name, category, unit_type, 
    created_at, created_by, updated_at, updated_by
)
SELECT DISTINCT ON (store_id, barcode) 
    store_id, 
    barcode, 
    name, 
    category, 
    unit_type,
    coalesce(updated_at, now()), -- Si no hay fecha, usamos ahora
    updated_by,                  -- Asumimos que el creador es el último que actualizó (proxy)
    coalesce(updated_at, now()), 
    updated_by
FROM public.products
WHERE store_id IS NOT NULL
ON CONFLICT DO NOTHING; -- Evitar errores si se corre múltiples veces

-- 2. Migrar Precios Históricos desde la tabla vieja 'products'
INSERT INTO public.branch_prices (
    branch_id, barcode, price, 
    created_at, created_by, updated_at, updated_by
)
SELECT 
    branch_id, 
    barcode, 
    price, 
    coalesce(updated_at, now()), 
    updated_by, 
    coalesce(updated_at, now()), 
    updated_by
FROM public.products
WHERE branch_id IS NOT NULL
ON CONFLICT DO NOTHING;

-- =================================================================
-- FASE 3: LA CAPA DE COMPATIBILIDAD (VIEW)
-- =================================================================

-- 1. Renombrar la tabla vieja para no perderla (Backup)
-- NOTA: Si ya corriste esto antes, puede dar error, puedes comentar esta línea
ALTER TABLE public.products RENAME TO products_backup_legacy;

-- 2. Crear la VISTA 'products'
-- Esta vista une las dos tablas nuevas para que la App crea que sigue leyendo la tabla vieja.
CREATE OR REPLACE VIEW public.products AS
SELECT 
    bp.barcode,
    s.name as store,
    b.name as branch,
    sp.name,
    bp.price,
    sp.category,
    sp.unit_type,
    bp.updated_at,
    bp.updated_by,
    sp.store_id,
    bp.branch_id
FROM 
    public.branch_prices bp
JOIN 
    public.branches b ON bp.branch_id = b.id
JOIN 
    public.stores s ON b.store_id = s.id
JOIN 
    public.store_products sp ON (sp.store_id = s.id AND sp.barcode = bp.barcode);

-- =================================================================
-- FASE 4: TRIGGER DE AUDITORÍA AUTOMÁTICA (Separación de Responsabilidades)
-- =================================================================

-- Función genérica para actualizar timestamp (Equivalente a un trigger standard en Oracle)
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Trigger para Catálogo
DROP TRIGGER IF EXISTS update_store_products_modtime ON public.store_products;
CREATE TRIGGER update_store_products_modtime
    BEFORE UPDATE ON public.store_products
    FOR EACH ROW EXECUTE PROCEDURE public.update_updated_at_column();

-- Trigger para Precios
DROP TRIGGER IF EXISTS update_branch_prices_modtime ON public.branch_prices;
CREATE TRIGGER update_branch_prices_modtime
    BEFORE UPDATE ON public.branch_prices
    FOR EACH ROW EXECUTE PROCEDURE public.update_updated_at_column();

-- =================================================================
-- FASE 5: EL JUEZ V3 (Lógica de Negocio Pura)
-- =================================================================

CREATE OR REPLACE FUNCTION public.process_price_report_v2()
RETURNS TRIGGER AS $$
DECLARE
  existing_price numeric;
  price_diff numeric;
  diff_percent numeric;
BEGIN
  -- 1. Actualizar o Crear el CATÁLOGO (Nombre/Categoría)
  -- Nota: Ya no seteamos updated_at manualmente, el trigger de Fase 4 lo hará
  INSERT INTO public.store_products (
      store_id, barcode, name, category, unit_type, 
      created_by, updated_by
  )
  VALUES (
      NEW.store_id, NEW.barcode, NEW.name, NEW.category, NEW.unit_type, 
      NEW.user_id, NEW.user_id
  )
  ON CONFLICT (store_id, barcode) 
  DO UPDATE SET 
      -- name = EXCLUDED.name, -- BLOQUEADO: El nombre original se respeta (El primero gana)
      category = EXCLUDED.category, -- Permitimos corregir categoría
      unit_type = EXCLUDED.unit_type, -- Permitimos corregir unidad
      updated_by = EXCLUDED.updated_by; -- Solo actualizamos quién lo hizo

  -- 2. Validar y Actualizar el PRECIO
  SELECT price INTO existing_price FROM public.branch_prices
  WHERE barcode = NEW.barcode AND branch_id = NEW.branch_id;

  IF existing_price IS NULL THEN
    -- A. Precio Nuevo -> Insertar con datos de creación
    INSERT INTO public.branch_prices (
        branch_id, barcode, price, 
        created_by, updated_by
    )
    VALUES (
        NEW.branch_id, NEW.barcode, NEW.price, 
        NEW.user_id, NEW.user_id
    );
    
    UPDATE price_reports SET status = 'approved', status_reason = '✨ Precio inicial registrado' WHERE id = NEW.id;
    
  ELSE
    -- B. Precio Existente -> Validar y actualizar auditoría
    price_diff := abs(NEW.price - existing_price);
    IF existing_price = 0 THEN diff_percent := 100; ELSE diff_percent := round((price_diff / existing_price) * 100, 0); END IF;

    IF price_diff < (existing_price * 0.5) THEN
      -- Aprobado
      UPDATE public.branch_prices
      SET price = NEW.price, 
          updated_by = NEW.user_id
      WHERE branch_id = NEW.branch_id AND barcode = NEW.barcode;
      
      UPDATE price_reports SET status = 'approved', status_reason = '✅ Actualizado (' || diff_percent || '%)' WHERE id = NEW.id;
    ELSE
      -- Rechazado
      UPDATE price_reports SET status = 'rejected', status_reason = '⚠️ Variación excesiva (' || diff_percent || '%)' WHERE id = NEW.id;
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Conectar el nuevo Juez a la tabla de reportes
DROP TRIGGER IF EXISTS on_new_report ON public.price_reports;

CREATE TRIGGER on_new_report
  AFTER INSERT ON public.price_reports
  FOR EACH ROW EXECUTE PROCEDURE public.process_price_report_v2();

-- =================================================================
-- FASE 6: SEGURIDAD (ROW LEVEL SECURITY - RLS)
-- =================================================================

-- 1. Habilitar RLS en las nuevas tablas
ALTER TABLE public.store_products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.branch_prices ENABLE ROW LEVEL SECURITY;

-- 2. Políticas de Lectura (Públicas para que la app funcione)
CREATE POLICY "Lectura Pública Catálogo" 
ON public.store_products FOR SELECT 
TO anon, authenticated 
USING (true);

CREATE POLICY "Lectura Pública Precios" 
ON public.branch_prices FOR SELECT 
TO anon, authenticated 
USING (true);

-- Nota: AL NO CREAR políticas de INSERT/UPDATE, bloqueamos implícitamente 
-- la escritura directa. Solo el Trigger (definido como SECURITY DEFINER) 
-- tendrá permisos para modificar estas tablas.

-- =================================================================
-- FASE 7: OPTIMIZACIÓN (ÍNDICES)
-- =================================================================

-- Índices para búsquedas rápidas por Código de Barras (La operación más común)
CREATE INDEX IF NOT EXISTS idx_branch_prices_barcode ON public.branch_prices(barcode);
CREATE INDEX IF NOT EXISTS idx_store_products_barcode ON public.store_products(barcode);

-- Índices para los cruces (JOINs) rápidos entre tablas
CREATE INDEX IF NOT EXISTS idx_branch_prices_branch_id ON public.branch_prices(branch_id);
CREATE INDEX IF NOT EXISTS idx_branches_store_id ON public.branches(store_id);

-- Índice para el historial/reportes (Para que el usuario vea sus reportes rápido)
CREATE INDEX IF NOT EXISTS idx_price_reports_barcode ON public.price_reports(barcode);
CREATE INDEX IF NOT EXISTS idx_price_reports_user_id ON public.price_reports(user_id);
CREATE INDEX IF NOT EXISTS idx_price_reports_created_at ON public.price_reports(created_at DESC);
